-- 004_inventory_consistency.sql
-- 目标：增加库存流水与触发器，保证入库/出库自动影响库存；并提供基于流水的校验视图

-- 库存表按 product_id 保证唯一，便于 upsert
DO $$ BEGIN
  ALTER TABLE inventory ADD CONSTRAINT uq_inventory_product UNIQUE (product_id);
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

-- 库存流水
CREATE TABLE IF NOT EXISTS inventory_movements (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id BIGINT NOT NULL REFERENCES products(id),
  qty INTEGER NOT NULL, -- 正数入库，负数出库
  source_type TEXT NOT NULL CHECK (source_type IN ('inbound','outbound','adjust')),
  source_id BIGINT,
  created_at TIMESTAMPTZ DEFAULT now(),
  note TEXT,
  UNIQUE (source_type, source_id, product_id)
);

CREATE INDEX IF NOT EXISTS idx_inv_mov_product ON inventory_movements(product_id);
CREATE INDEX IF NOT EXISTS idx_inv_mov_created ON inventory_movements(created_at DESC);

-- 应用库存增量（不存在则创建）
CREATE OR REPLACE FUNCTION apply_inventory_delta(p_product_id BIGINT, p_delta INTEGER)
RETURNS VOID LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO inventory(product_id, current_stock, reserved_stock, available_stock, last_updated)
  VALUES (p_product_id, GREATEST(0, p_delta), 0, GREATEST(0, p_delta), now())
  ON CONFLICT (product_id) DO UPDATE SET
    current_stock = GREATEST(0, inventory.current_stock + EXCLUDED.current_stock),
    available_stock = GREATEST(0, inventory.available_stock + EXCLUDED.available_stock),
    last_updated = now();
END;$$;

-- 入库触发器：插入/更新/删除
CREATE OR REPLACE FUNCTION trg_inbound_inventory_ai()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
  VALUES (NEW.product_id, NEW.quantity, 'inbound', NEW.id, 'auto')
  ON CONFLICT (source_type, source_id, product_id) DO NOTHING;
  PERFORM apply_inventory_delta(NEW.product_id, NEW.quantity);
  RETURN NEW;
END;$$;

CREATE OR REPLACE FUNCTION trg_inbound_inventory_au()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE
  delta INTEGER;
BEGIN
  IF NEW.product_id = OLD.product_id THEN
    delta := COALESCE(NEW.quantity,0) - COALESCE(OLD.quantity,0);
    IF delta <> 0 THEN
      INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
      VALUES (NEW.product_id, delta, 'inbound', NEW.id, 'adjust')
      ON CONFLICT DO NOTHING;
      PERFORM apply_inventory_delta(NEW.product_id, delta);
    END IF;
  ELSE
    -- 还原旧商品数量，再增加新商品数量
    INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
    VALUES (OLD.product_id, -COALESCE(OLD.quantity,0), 'inbound', NEW.id, 'relink-old')
    ON CONFLICT DO NOTHING;
    PERFORM apply_inventory_delta(OLD.product_id, -COALESCE(OLD.quantity,0));

    INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
    VALUES (NEW.product_id, COALESCE(NEW.quantity,0), 'inbound', NEW.id, 'relink-new')
    ON CONFLICT DO NOTHING;
    PERFORM apply_inventory_delta(NEW.product_id, COALESCE(NEW.quantity,0));
  END IF;
  RETURN NEW;
END;$$;

CREATE OR REPLACE FUNCTION trg_inbound_inventory_bd()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
  VALUES (OLD.product_id, -OLD.quantity, 'inbound', OLD.id, 'delete')
  ON CONFLICT DO NOTHING;
  PERFORM apply_inventory_delta(OLD.product_id, -OLD.quantity);
  RETURN OLD;
END;$$;

DROP TRIGGER IF EXISTS inbound_ai ON inbound_records;
DROP TRIGGER IF EXISTS inbound_au ON inbound_records;
DROP TRIGGER IF EXISTS inbound_bd ON inbound_records;
CREATE TRIGGER inbound_ai AFTER INSERT ON inbound_records FOR EACH ROW EXECUTE FUNCTION trg_inbound_inventory_ai();
CREATE TRIGGER inbound_au AFTER UPDATE ON inbound_records FOR EACH ROW EXECUTE FUNCTION trg_inbound_inventory_au();
CREATE TRIGGER inbound_bd BEFORE DELETE ON inbound_records FOR EACH ROW EXECUTE FUNCTION trg_inbound_inventory_bd();

-- 出库触发器：插入/更新/删除（数量为负）
CREATE OR REPLACE FUNCTION trg_outbound_inventory_ai()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
  VALUES (NEW.product_id, -NEW.quantity, 'outbound', NEW.id, 'auto')
  ON CONFLICT (source_type, source_id, product_id) DO NOTHING;
  PERFORM apply_inventory_delta(NEW.product_id, -NEW.quantity);
  RETURN NEW;
END;$$;

CREATE OR REPLACE FUNCTION trg_outbound_inventory_au()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE
  delta INTEGER;
BEGIN
  IF NEW.product_id = OLD.product_id THEN
    delta := -COALESCE(NEW.quantity,0) + COALESCE(OLD.quantity,0);
    IF delta <> 0 THEN
      INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
      VALUES (NEW.product_id, delta, 'outbound', NEW.id, 'adjust')
      ON CONFLICT DO NOTHING;
      PERFORM apply_inventory_delta(NEW.product_id, delta);
    END IF;
  ELSE
    INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
    VALUES (OLD.product_id, COALESCE(OLD.quantity,0), 'outbound', NEW.id, 'relink-old')
    ON CONFLICT DO NOTHING;
    PERFORM apply_inventory_delta(OLD.product_id, COALESCE(OLD.quantity,0));

    INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
    VALUES (NEW.product_id, -COALESCE(NEW.quantity,0), 'outbound', NEW.id, 'relink-new')
    ON CONFLICT DO NOTHING;
    PERFORM apply_inventory_delta(NEW.product_id, -COALESCE(NEW.quantity,0));
  END IF;
  RETURN NEW;
END;$$;

CREATE OR REPLACE FUNCTION trg_outbound_inventory_bd()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO inventory_movements(product_id, qty, source_type, source_id, note)
  VALUES (OLD.product_id, OLD.quantity, 'outbound', OLD.id, 'delete')
  ON CONFLICT DO NOTHING;
  PERFORM apply_inventory_delta(OLD.product_id, OLD.quantity);
  RETURN OLD;
END;$$;

DROP TRIGGER IF EXISTS outbound_ai ON outbound_records;
DROP TRIGGER IF EXISTS outbound_au ON outbound_records;
DROP TRIGGER IF EXISTS outbound_bd ON outbound_records;
CREATE TRIGGER outbound_ai AFTER INSERT ON outbound_records FOR EACH ROW EXECUTE FUNCTION trg_outbound_inventory_ai();
CREATE TRIGGER outbound_au AFTER UPDATE ON outbound_records FOR EACH ROW EXECUTE FUNCTION trg_outbound_inventory_au();
CREATE TRIGGER outbound_bd BEFORE DELETE ON outbound_records FOR EACH ROW EXECUTE FUNCTION trg_outbound_inventory_bd();

-- 基于流水的库存视图（用于校验）
CREATE OR REPLACE VIEW v_inventory_from_movements AS
SELECT p.id AS product_id,
       p.sku,
       p.name,
       COALESCE(SUM(m.qty),0) AS calc_current_stock
FROM products p
LEFT JOIN inventory_movements m ON m.product_id = p.id
GROUP BY p.id, p.sku, p.name;


